<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/MemRef/IR/MemRefOps.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">16.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_aa550efc2eb1acee4ac7619e105a3637.html">MemRef</a></li><li class="navelem"><a class="el" href="dir_bbff0bc417424c2f220526a400d79936.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MemRefOps.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html">mlir/Dialect/MemRef/Utils/MemRefUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StaticValueUtils_8h_source.html">mlir/Dialect/Utils/StaticValueUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Builders_8h_source.html">mlir/IR/Builders.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2BuiltinTypes_8h_source.html">mlir/IR/BuiltinTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Matchers_8h_source.html">mlir/IR/Matchers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeUtilities_8h_source.html">mlir/IR/TypeUtilities.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InferTypeOpInterface_8h_source.html">mlir/Interfaces/InferTypeOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SideEffectInterfaces_8h_source.html">mlir/Interfaces/SideEffectInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ViewLikeInterface_8h_source.html">mlir/Interfaces/ViewLikeInterface.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallBitVector.h&quot;</code><br />
<code>#include &quot;mlir/Dialect/MemRef/IR/MemRefOps.cpp.inc&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for MemRefOps.cpp:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="MemRefOps_8cpp__incl.png" border="0" usemap="#lib_2Dialect_2MemRef_2IR_2MemRefOps_8cpp" alt=""/></div>
<map name="lib_2Dialect_2MemRef_2IR_2MemRefOps_8cpp" id="lib_2Dialect_2MemRef_2IR_2MemRefOps_8cpp">
<area shape="rect" id="node2" href="Arith_8h.html" title="mlir/Dialect/Arith\l/IR/Arith.h" alt="" coords="1609,273,1743,315"/>
<area shape="rect" id="node6" href="IR_2BuiltinTypes_8h.html" title="mlir/IR/BuiltinTypes.h" alt="" coords="2431,541,2591,568"/>
<area shape="rect" id="node8" href="IR_2AffineMap_8h.html" title="mlir/IR/AffineMap.h" alt="" coords="1925,705,2072,732"/>
<area shape="rect" id="node19" href="InferTypeOpInterface_8h.html" title="mlir/Interfaces/InferType\lOpInterface.h" alt="" coords="2616,363,2797,404"/>
<area shape="rect" id="node20" href="Builders_8h.html" title="mlir/IR/Builders.h" alt="" coords="2873,459,3007,486"/>
<area shape="rect" id="node23" href="SideEffectInterfaces_8h.html" title="mlir/Interfaces/SideEffect\lInterfaces.h" alt="" coords="505,452,692,493"/>
<area shape="rect" id="node31" href="Dialect_2Arith_2Utils_2Utils_8h.html" title="mlir/Dialect/Arith\l/Utils/Utils.h" alt="" coords="2904,184,3037,225"/>
<area shape="rect" id="node32" href="Matchers_8h.html" title="mlir/IR/Matchers.h" alt="" coords="2991,281,3131,307"/>
<area shape="rect" id="node33" href="PatternMatch_8h.html" title="mlir/IR/PatternMatch.h" alt="" coords="2797,281,2963,307"/>
<area shape="rect" id="node37" href="MemRef_8h.html" title="mlir/Dialect/MemRef\l/IR/MemRef.h" alt="" coords="1195,95,1349,136"/>
<area shape="rect" id="node39" href="StaticValueUtils_8h.html" title="mlir/Dialect/Utils\l/StaticValueUtils.h" alt="" coords="2349,363,2491,404"/>
<area shape="rect" id="node44" href="ViewLikeInterface_8h.html" title="mlir/Interfaces/ViewLike\lInterface.h" alt="" coords="2514,273,2694,315"/>
<area shape="rect" id="node47" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h.html" title="mlir/Dialect/MemRef\l/Utils/MemRefUtils.h" alt="" coords="3445,95,3600,136"/>
<area shape="rect" id="node48" href="TypeUtilities_8h.html" title="mlir/IR/TypeUtilities.h" alt="" coords="3624,102,3787,129"/>
<area shape="rect" id="node3" href="IR_2Dialect_8h.html" title="mlir/IR/Dialect.h" alt="" coords="405,623,531,650"/>
<area shape="rect" id="node4" href="OpDefinition_8h.html" title="mlir/IR/OpDefinition.h" alt="" coords="1597,541,1760,568"/>
<area shape="rect" id="node5" href="OpImplementation_8h.html" title="mlir/IR/OpImplementation.h" alt="" coords="2192,459,2395,486"/>
<area shape="rect" id="node17" href="CastInterfaces_8h.html" title="mlir/Interfaces/CastInterfaces.h" alt="" coords="1232,459,1459,486"/>
<area shape="rect" id="node18" href="InferIntRangeInterface_8h.html" title="mlir/Interfaces/InferInt\lRangeInterface.h" alt="" coords="1533,452,1701,493"/>
<area shape="rect" id="node24" href="VectorInterfaces_8h.html" title="mlir/Interfaces/VectorInterfaces.h" alt="" coords="1929,459,2167,486"/>
<area shape="rect" id="node7" href="BuiltinAttributeInterfaces_8h.html" title="mlir/IR/BuiltinAttribute\lInterfaces.h" alt="" coords="2087,616,2255,657"/>
<area shape="rect" id="node14" href="BuiltinTypeInterfaces_8h.html" title="mlir/IR/BuiltinTypeInterfaces.h" alt="" coords="2165,705,2384,732"/>
<area shape="rect" id="node15" href="SubElementInterfaces_8h.html" title="mlir/IR/SubElementInterfaces.h" alt="" coords="2329,623,2553,650"/>
<area shape="rect" id="node9" href="IR_2AffineExpr_8h.html" title="mlir/IR/AffineExpr.h" alt="" coords="1925,780,2072,807"/>
<area shape="rect" id="node10" href="Support_2LLVM_8h.html" title="mlir/Support/LLVM.h" alt="" coords="2165,855,2315,881"/>
<area shape="rect" id="node36" href="Value_8h.html" title="mlir/IR/Value.h" alt="" coords="3293,705,3411,732"/>
<area shape="rect" id="node34" href="BuiltinOps_8h.html" title="mlir/IR/BuiltinOps.h" alt="" coords="1974,370,2122,397"/>
<area shape="rect" id="node38" href="ReshapeOpsUtils_8h.html" title="mlir/Dialect/Utils\l/ReshapeOpsUtils.h" alt="" coords="2238,184,2386,225"/>
<area shape="rect" id="node40" href="CallInterfaces_8h.html" title="mlir/Interfaces/CallInterfaces.h" alt="" coords="923,191,1146,218"/>
<area shape="rect" id="node41" href="ControlFlowInterfaces_8h.html" title="mlir/Interfaces/ControlFlow\lInterfaces.h" alt="" coords="1922,273,2121,315"/>
<area shape="rect" id="node42" href="CopyOpInterface_8h.html" title="mlir/Interfaces/CopyOpInterface.h" alt="" coords="195,281,437,307"/>
<area shape="rect" id="node43" href="ShapedOpInterfaces_8h.html" title="mlir/Interfaces/ShapedOp\lInterfaces.h" alt="" coords="93,452,280,493"/>
</map>
</div>
</div>
<p><a href="MemRefOps_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAllocaScopeInliner.html">AllocaScopeInliner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline an AllocaScopeOp if either the direct parent is an allocation scope or it contains no allocation.  <a href="structAllocaScopeInliner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAllocaScopeHoister.html">AllocaScopeHoister</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move allocations into an allocation scope, if it is legal to move them (e.g.  <a href="structAllocaScopeHoister.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCollapseShapeOpMemRefCastFolder.html">CollapseShapeOpMemRefCastFolder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSubViewReturnTypeCanonicalizer.html">SubViewReturnTypeCanonicalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the canonical type of the result of a subview.  <a href="structSubViewReturnTypeCanonicalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSubViewCanonicalizer.html">SubViewCanonicalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A canonicalizer wrapper to replace SubViewOps.  <a href="structSubViewCanonicalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesaturated__arith"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesaturated__arith.html">saturated_arith</a></td></tr>
<tr class="memdesc:namespacesaturated__arith"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idiomatic saturated operations on offsets, sizes and strides. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a52c883a38e577b8b12282ff70c95a16d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a52c883a38e577b8b12282ff70c95a16d">GET_OP_CLASSES</a></td></tr>
<tr class="separator:a52c883a38e577b8b12282ff70c95a16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afcb10f259303d819184a4c81b159372a"><td class="memTemplParams" colspan="2">template&lt;typename AllocLikeOp &gt; </td></tr>
<tr class="memitem:afcb10f259303d819184a4c81b159372a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#afcb10f259303d819184a4c81b159372a">verifyAllocLikeOp</a> (AllocLikeOp op)</td></tr>
<tr class="separator:afcb10f259303d819184a4c81b159372a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2e419c24e30507c54a8d5942359751"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a5a2e419c24e30507c54a8d5942359751">isGuaranteedAutomaticAllocation</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a5a2e419c24e30507c54a8d5942359751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, return whether this op is guaranteed to allocate an AutomaticAllocationScopeResource.  <a href="#a5a2e419c24e30507c54a8d5942359751">More...</a><br /></td></tr>
<tr class="separator:a5a2e419c24e30507c54a8d5942359751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4397b9a83c219ccae94d6fc4b14f6f32"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a4397b9a83c219ccae94d6fc4b14f6f32">isOpItselfPotentialAutomaticAllocation</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a4397b9a83c219ccae94d6fc4b14f6f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, return whether this op itself could allocate an AutomaticAllocationScopeResource.  <a href="#a4397b9a83c219ccae94d6fc4b14f6f32">More...</a><br /></td></tr>
<tr class="separator:a4397b9a83c219ccae94d6fc4b14f6f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38e621303868d5773129812aaa74af7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#ac38e621303868d5773129812aaa74af7">lastNonTerminatorInRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac38e621303868d5773129812aaa74af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this op is the last non terminating op in a region.  <a href="#ac38e621303868d5773129812aaa74af7">More...</a><br /></td></tr>
<tr class="separator:ac38e621303868d5773129812aaa74af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8ee1edd7328998d47a287dc8185d6a"><td class="memItemLeft" align="right" valign="top">static std::map&lt; int64_t, <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#adc8ee1edd7328998d47a287dc8185d6a">getNumOccurences</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; vals)</td></tr>
<tr class="memdesc:adc8ee1edd7328998d47a287dc8185d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map with key being elements in <code>vals</code> and data being number of occurences of it.  <a href="#adc8ee1edd7328998d47a287dc8185d6a">More...</a><br /></td></tr>
<tr class="separator:adc8ee1edd7328998d47a287dc8185d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94b5a6a84a1fa58a42a419acf9441bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; llvm::SmallBitVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#af94b5a6a84a1fa58a42a419acf9441bc">computeMemRefRankReductionMask</a> (MemRefType originalType, MemRefType reducedType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes)</td></tr>
<tr class="memdesc:af94b5a6a84a1fa58a42a419acf9441bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the <code>originalType</code> and a <code>candidateReducedType</code> whose shape is assumed to be a subset of <code>originalType</code> with some <code>1</code> entries erased, return the set of indices that specifies which of the entries of <code>originalShape</code> are dropped to obtain <code>reducedShape</code>.  <a href="#af94b5a6a84a1fa58a42a419acf9441bc">More...</a><br /></td></tr>
<tr class="separator:af94b5a6a84a1fa58a42a419acf9441bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8ebb88a6b0251c5ae942554571d621"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a4c8ebb88a6b0251c5ae942554571d621"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a4c8ebb88a6b0251c5ae942554571d621">replaceConstantUsesOf</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, Container values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; maybeConstants, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(int64_t)&gt; isDynamic)</td></tr>
<tr class="memdesc:a4c8ebb88a6b0251c5ae942554571d621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to perform the replacement of all constant uses of <code>values</code> by a materialized constant extracted from <code>maybeConstants</code>.  <a href="#a4c8ebb88a6b0251c5ae942554571d621">More...</a><br /></td></tr>
<tr class="separator:a4c8ebb88a6b0251c5ae942554571d621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265e2c0706658d6b14273bba2445f3dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a265e2c0706658d6b14273bba2445f3dc">printGlobalMemrefOpTypeAndInitialValue</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, GlobalOp op, TypeAttr type, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> initialValue)</td></tr>
<tr class="separator:a265e2c0706658d6b14273bba2445f3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdfa23b2974217feca58562d9915084"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#aafdfa23b2974217feca58562d9915084">parseGlobalMemrefOpTypeAndInitialValue</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, TypeAttr &amp;typeAttr, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;initialValue)</td></tr>
<tr class="separator:aafdfa23b2974217feca58562d9915084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3211f00d69d9462b4103bba629b75337"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a3211f00d69d9462b4103bba629b75337">verifyCollapsedShape</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; collapsedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expandedShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociation, bool allowMultipleDynamicDimsPerGroup)</td></tr>
<tr class="memdesc:a3211f00d69d9462b4103bba629b75337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for verifying the shape of ExpandShapeOp and ResultShapeOp result and operand.  <a href="#a3211f00d69d9462b4103bba629b75337">More...</a><br /></td></tr>
<tr class="separator:a3211f00d69d9462b4103bba629b75337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74a2ddd3de03f1670d7743be51b0205"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; StridedLayoutAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#ae74a2ddd3de03f1670d7743be51b0205">computeExpandedLayoutMap</a> (MemRefType srcType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; resultShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociation)</td></tr>
<tr class="memdesc:ae74a2ddd3de03f1670d7743be51b0205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the layout map after expanding a given source MemRef type with the specified reassociation indices.  <a href="#ae74a2ddd3de03f1670d7743be51b0205">More...</a><br /></td></tr>
<tr class="separator:ae74a2ddd3de03f1670d7743be51b0205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1ae8369e10d64675d9ff2a5941a138"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; StridedLayoutAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#aeb1ae8369e10d64675d9ff2a5941a138">computeCollapsedLayoutMap</a> (MemRefType srcType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt; reassociation, bool strict=false)</td></tr>
<tr class="memdesc:aeb1ae8369e10d64675d9ff2a5941a138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the layout map after collapsing a given source MemRef type with the specified reassociation indices.  <a href="#aeb1ae8369e10d64675d9ff2a5941a138">More...</a><br /></td></tr>
<tr class="separator:aeb1ae8369e10d64675d9ff2a5941a138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6901e2de1f1e535ad6db31a96b7a0b1d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a6901e2de1f1e535ad6db31a96b7a0b1d">haveCompatibleOffsets</a> (MemRefType t1, MemRefType t2)</td></tr>
<tr class="memdesc:a6901e2de1f1e535ad6db31a96b7a0b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if t1 and t2 have equal offsets (both dynamic or of same static value).  <a href="#a6901e2de1f1e535ad6db31a96b7a0b1d">More...</a><br /></td></tr>
<tr class="separator:a6901e2de1f1e535ad6db31a96b7a0b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242cc0a684a291991d512f9dd8ed75ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a242cc0a684a291991d512f9dd8ed75ee">isRankReducedMemRefType</a> (MemRefType originalType, MemRefType candidateRankReducedType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes)</td></tr>
<tr class="memdesc:a242cc0a684a291991d512f9dd8ed75ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>original</code> Type type can be rank reduced to <code>reduced</code> type.  <a href="#a242cc0a684a291991d512f9dd8ed75ee">More...</a><br /></td></tr>
<tr class="separator:a242cc0a684a291991d512f9dd8ed75ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9684bbc8a0bb512dfa8dcd662c86a5"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a9d9684bbc8a0bb512dfa8dcd662c86a5"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a9d9684bbc8a0bb512dfa8dcd662c86a5">produceSubViewErrorMsg</a> (<a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> result, OpTy op, <a class="el" href="classmlir_1_1Type.html">Type</a> expectedType)</td></tr>
<tr class="separator:a9d9684bbc8a0bb512dfa8dcd662c86a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902a21badb61387b3a01cf900a97e39e"><td class="memItemLeft" align="right" valign="top">static MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a902a21badb61387b3a01cf900a97e39e">getCanonicalSubViewResultType</a> (MemRefType currentResultType, MemRefType currentSourceType, MemRefType sourceType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedStrides)</td></tr>
<tr class="memdesc:a902a21badb61387b3a01cf900a97e39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the canonical result type of a SubViewOp.  <a href="#a902a21badb61387b3a01cf900a97e39e">More...</a><br /></td></tr>
<tr class="separator:a902a21badb61387b3a01cf900a97e39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa979f6a25bd9431e0a3ed13fdd9200"><td class="memItemLeft" align="right" valign="top">static MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a9fa979f6a25bd9431e0a3ed13fdd9200">getCanonicalSubViewResultType</a> (MemRefType currentResultType, MemRefType sourceType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedStrides)</td></tr>
<tr class="memdesc:a9fa979f6a25bd9431e0a3ed13fdd9200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the canonical result type of a SubViewOp.  <a href="#a9fa979f6a25bd9431e0a3ed13fdd9200">More...</a><br /></td></tr>
<tr class="separator:a9fa979f6a25bd9431e0a3ed13fdd9200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac299274eab542658ab296d7ebcb24621"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#ac299274eab542658ab296d7ebcb24621">isTrivialSubViewOp</a> (SubViewOp subViewOp)</td></tr>
<tr class="memdesc:ac299274eab542658ab296d7ebcb24621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to check if a <code>subview</code> operation is trivially a no-op.  <a href="#ac299274eab542658ab296d7ebcb24621">More...</a><br /></td></tr>
<tr class="separator:ac299274eab542658ab296d7ebcb24621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4da491ebeafb1a779b58a6bffa499c"><td class="memItemLeft" align="right" valign="top">static MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MemRefOps_8cpp.html#a4c4da491ebeafb1a779b58a6bffa499c">inferTransposeResultType</a> (MemRefType memRefType, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> permutationMap)</td></tr>
<tr class="memdesc:a4c4da491ebeafb1a779b58a6bffa499c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a strided memref type by applying <code>permutationMap</code> tp <code>memRefType</code>.  <a href="#a4c4da491ebeafb1a779b58a6bffa499c">More...</a><br /></td></tr>
<tr class="separator:a4c4da491ebeafb1a779b58a6bffa499c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a52c883a38e577b8b12282ff70c95a16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c883a38e577b8b12282ff70c95a16d">&#9670;&nbsp;</a></span>GET_OP_CLASSES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_OP_CLASSES</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03166">3166</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aeb1ae8369e10d64675d9ff2a5941a138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1ae8369e10d64675d9ff2a5941a138">&#9670;&nbsp;</a></span>computeCollapsedLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;StridedLayoutAttr&gt; computeCollapsedLayoutMap </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>srcType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the layout map after collapsing a given source MemRef type with the specified reassociation indices. </p>
<p>Note: All collapsed dims in a reassociation group must be contiguous. It is not possible to check this by inspecting a MemRefType in the general case. If non-contiguity cannot be checked statically, the collapse is assumed to be valid (and thus accepted by this function) unless <code>strict = true</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02068">2068</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00665">mlir::OperationState::addAttribute()</a>, <a class="el" href="IR_2Types_8h_source.html#l00279">mlir::Type::cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00030">mlir::getReassociationAttrName()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00159">mlir::getReassociationIndicesAttribute()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00844">mlir::getStridesAndOffset()</a>, <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="Verifier_8cpp_source.html#l00372">mlir::verify()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l01863">verifyCollapsedShape()</a>.</p>

</div>
</div>
<a id="ae74a2ddd3de03f1670d7743be51b0205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74a2ddd3de03f1670d7743be51b0205">&#9670;&nbsp;</a></span>computeExpandedLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;StridedLayoutAttr&gt; computeExpandedLayoutMap </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>srcType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>resultShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the layout map after expanding a given source MemRef type with the specified reassociation indices. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l01956">1956</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="IR_2Types_8h_source.html#l00279">mlir::Type::cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00844">mlir::getStridesAndOffset()</a>, <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="Verifier_8cpp_source.html#l00372">mlir::verify()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l01863">verifyCollapsedShape()</a>.</p>

</div>
</div>
<a id="af94b5a6a84a1fa58a42a419acf9441bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94b5a6a84a1fa58a42a419acf9441bc">&#9670;&nbsp;</a></span>computeMemRefRankReductionMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt;llvm::SmallBitVector&gt; computeMemRefRankReductionMask </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>originalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>reducedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the <code>originalType</code> and a <code>candidateReducedType</code> whose shape is assumed to be a subset of <code>originalType</code> with some <code>1</code> entries erased, return the set of indices that specifies which of the entries of <code>originalShape</code> are dropped to obtain <code>reducedShape</code>. </p>
<p>This accounts for cases where there are multiple unit-dims, but only a subset of those are dropped. For MemRefTypes these can be disambiguated using the strides. If a dimension is dropped the stride must be dropped too. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00869">869</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00195">mlir::OperationState::addOperands()</a>, <a class="el" href="Builders_8cpp_source.html#l00418">mlir::OpBuilder::create()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00089">mlir::memref::foldMemRefCast()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00105">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00052">mlir::Builder::getIndexType()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00173">mlir::getMixedSizes()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="TensorOps_8cpp_source.html#l01252">getNumElements()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00854">getNumOccurences()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00844">mlir::getStridesAndOffset()</a>, <a class="el" href="Value_8h_source.html#l00114">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00029">mlir::Type::isIndex()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01009">mlir::isStrided()</a>, <a class="el" href="OperationSupport_8h_source.html#l00631">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1AsmParser.html#a1313f3689e72471402e478d479ff269b">mlir::AsmParser::parseColonTypeList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ac6ae46c606240d5588dbd91262f3a9a4">mlir::AsmParser::parseComma()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#ac30f229849bfc580b251da20cc8923ee">mlir::OpAsmParser::parseOperand()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, <a class="el" href="OpImplementation_8h_source.html#l01372">mlir::OpAsmParser::parseTrailingOperandList()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00602">print()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#a681280bde1406e824e1d4626fe257e1b">mlir::OpAsmPrinter::printOptionalAttrDict()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">mlir::OpAsmParser::resolveOperand()</a>, <a class="el" href="OpImplementation_8h_source.html#l01388">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="Operator_8cpp_source.html#l00308">resultIndex()</a>, <a class="el" href="Builders_8h_source.html#l00363">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">mlir::AsmParser::Square</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="Verifier_8cpp_source.html#l00372">mlir::verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l02686">getCanonicalSubViewResultType()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l02567">isRankReducedMemRefType()</a>.</p>

</div>
</div>
<a id="a902a21badb61387b3a01cf900a97e39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902a21badb61387b3a01cf900a97e39e">&#9670;&nbsp;</a></span>getCanonicalSubViewResultType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MemRefType getCanonicalSubViewResultType </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>currentResultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>currentSourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedStrides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the canonical result type of a SubViewOp. </p>
<p>Call <code>inferResultType</code> to deduce the result type for the given <code>sourceType</code>. Additionally, reduce the rank of the inferred result type if <code>currentResultType</code> is lower rank than <code>currentSourceType</code>. Use this signature if <code>sourceType</code> is updated together with the result type. In this case, it is important to compute the dropped dimensions using <code>currentSourceType</code> whose strides align with <code>currentResultType</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02686">2686</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefOps_8cpp_source.html#l00869">computeMemRefRankReductionMask()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l02724">getCanonicalSubViewResultType()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02737">isTrivialSubViewOp()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l02853">SubViewReturnTypeCanonicalizer::operator()()</a>.</p>

</div>
</div>
<a id="a9fa979f6a25bd9431e0a3ed13fdd9200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa979f6a25bd9431e0a3ed13fdd9200">&#9670;&nbsp;</a></span>getCanonicalSubViewResultType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MemRefType getCanonicalSubViewResultType </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>currentResultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedStrides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the canonical result type of a SubViewOp. </p>
<p>Call <code>inferResultType</code> to deduce the result type. Additionally, reduce the rank of the inferred result type if <code>currentResultType</code> is lower rank than <code>sourceType</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02724">2724</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefOps_8cpp_source.html#l02686">getCanonicalSubViewResultType()</a>.</p>

</div>
</div>
<a id="adc8ee1edd7328998d47a287dc8185d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8ee1edd7328998d47a287dc8185d6a">&#9670;&nbsp;</a></span>getNumOccurences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::map&lt;int64_t, <a class="el" href="classunsigned.html">unsigned</a>&gt; getNumOccurences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a map with key being elements in <code>vals</code> and data being number of occurences of it. </p>
<p>Use std::map, since the <code>vals</code> here are strides and the dynamic stride value is the same as the tombstone value for <code>DenseMap&lt;int64_t&gt;</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00854">854</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00869">computeMemRefRankReductionMask()</a>.</p>

</div>
</div>
<a id="a6901e2de1f1e535ad6db31a96b7a0b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6901e2de1f1e535ad6db31a96b7a0b1d">&#9670;&nbsp;</a></span>haveCompatibleOffsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool haveCompatibleOffsets </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if t1 and t2 have equal offsets (both dynamic or of same static value). </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02555">2555</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00844">mlir::getStridesAndOffset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l02567">isRankReducedMemRefType()</a>.</p>

</div>
</div>
<a id="a4c4da491ebeafb1a779b58a6bffa499c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4da491ebeafb1a779b58a6bffa499c">&#9670;&nbsp;</a></span>inferTransposeResultType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MemRefType inferTransposeResultType </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memRefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>permutationMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a strided memref type by applying <code>permutationMap</code> tp <code>memRefType</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02899">2899</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

</div>
</div>
<a id="a5a2e419c24e30507c54a8d5942359751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2e419c24e30507c54a8d5942359751">&#9670;&nbsp;</a></span>isGuaranteedAutomaticAllocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isGuaranteedAutomaticAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an operation, return whether this op is guaranteed to allocate an AutomaticAllocationScopeResource. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00359">359</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00451">AllocaScopeHoister::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a4397b9a83c219ccae94d6fc4b14f6f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4397b9a83c219ccae94d6fc4b14f6f32">&#9670;&nbsp;</a></span>isOpItselfPotentialAutomaticAllocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isOpItselfPotentialAutomaticAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an operation, return whether this op itself could allocate an AutomaticAllocationScopeResource. </p>
<p>Note that this will not check whether an operation contained within the op can allocate. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00378">378</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00528">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00411">AllocaScopeInliner::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a242cc0a684a291991d512f9dd8ed75ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242cc0a684a291991d512f9dd8ed75ee">&#9670;&nbsp;</a></span>isRankReducedMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a> isRankReducedMemRefType </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>originalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>candidateRankReducedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>original</code> Type type can be rank reduced to <code>reduced</code> type. </p>
<p>This function is slight variant of <code>is subsequence</code> algorithm where not matching dimension must be 1. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02567">2567</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefOps_8cpp_source.html#l00869">computeMemRefRankReductionMask()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02555">haveCompatibleOffsets()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00465">mlir::isRankReducedType()</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca">mlir::LayoutMismatch</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23">mlir::MemSpaceMismatch</a>, and <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">mlir::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l02593">produceSubViewErrorMsg()</a>.</p>

</div>
</div>
<a id="ac299274eab542658ab296d7ebcb24621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac299274eab542658ab296d7ebcb24621">&#9670;&nbsp;</a></span>isTrivialSubViewOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isTrivialSubViewOp </td>
          <td>(</td>
          <td class="paramtype">SubViewOp&#160;</td>
          <td class="paramname"><em>subViewOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to check if a <code>subview</code> operation is trivially a no-op. </p>
<p>This is the case if the all offsets are zero, all strides are 1, and the source shape is same as the size of the subview. In such cases, the subview can be folded into its source. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02737">2737</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00169">mlir::tensor::canFoldIntoConsumerOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00418">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02686">getCanonicalSubViewResultType()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00096">mlir::getConstantIntValue()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00022">mlir::matchConstantIndex()</a>, <a class="el" href="Matchers_8h_source.html#l00329">mlir::matchPattern()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00451">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="ac38e621303868d5773129812aaa74af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38e621303868d5773129812aaa74af7">&#9670;&nbsp;</a></span>lastNonTerminatorInRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool lastNonTerminatorInRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether this op is the last non terminating op in a region. </p>
<p>That is to say, it is in a one-block region and is only followed by a terminator. This prevents extending the lifetime of allocations. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00401">401</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00144">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::getBlocks()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getParentRegion()</a>, and <a class="el" href="Block_8cpp_source.html#l00232">mlir::Block::getTerminator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00411">AllocaScopeInliner::matchAndRewrite()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l00451">AllocaScopeHoister::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="aafdfa23b2974217feca58562d9915084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdfa23b2974217feca58562d9915084">&#9670;&nbsp;</a></span>parseGlobalMemrefOpTypeAndInitialValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> parseGlobalMemrefOpTypeAndInitialValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeAttr &amp;&#160;</td>
          <td class="paramname"><em>typeAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l01442">1442</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="OperationSupport_8h_source.html#l00665">mlir::OperationState::addAttribute()</a>, <a class="el" href="OperationSupport_8h_source.html#l00675">mlir::OperationState::addAttributes()</a>, <a class="el" href="OperationSupport_8h_source.html#l00634">mlir::OperationState::attributes</a>, <a class="el" href="IR_2Types_8h_source.html#l00279">mlir::Type::cast()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00052">mlir::dispatchIndexOpFoldResults()</a>, <a class="el" href="Attributes_8h_source.html#l00127">mlir::Attribute::dyn_cast()</a>, <a class="el" href="IR_2Types_8h_source.html#l00269">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00327">mlir::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00061">mlir::extractFromI64ArrayAttr()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00089">mlir::memref::foldMemRefCast()</a>, <a class="el" href="Builders_8cpp_source.html#l00097">mlir::Builder::getBoolAttr()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00067">mlir::AsmParser::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00258">mlir::Builder::getI64ArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00109">mlir::Builder::getI64IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00052">mlir::Builder::getIndexType()</a>, <a class="el" href="OptimizeSharedMemory_8cpp_source.html#l00110">getIndices()</a>, <a class="el" href="Builders_8cpp_source.html#l00068">mlir::Builder::getIntegerType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00414">mlir::BaseMemRefType::getMemorySpace()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00731">mlir::bufferization::getMemRefType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00844">mlir::getStridesAndOffset()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00104">mlir::memref::getTensorTypeFromMemRefType()</a>, <a class="el" href="Attributes_8h_source.html#l00117">mlir::Attribute::isa()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00112">mlir::isConstantIntValue()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00956">mlir::SymbolTableCollection::lookupNearestSymbolFrom()</a>, <a class="el" href="OperationSupport_8h_source.html#l00631">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a709cff503c00735e0a35ecd795364a2a">mlir::AsmParser::parseColonType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ac6ae46c606240d5588dbd91262f3a9a4">mlir::AsmParser::parseComma()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ab0c07420f37ac78e5376cccc48e6e0d4">mlir::AsmParser::parseGreater()</a>, <a class="el" href="OpImplementation_8h_source.html#l00760">mlir::AsmParser::parseKeyword()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a552432315336762e7c3145941cbe625f">mlir::AsmParser::parseLess()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#ac30f229849bfc580b251da20cc8923ee">mlir::OpAsmParser::parseOperand()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2d725d47025c0e22ca8b2d44fce78ea7">mlir::AsmParser::parseOptionalEqual()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ab85d23c93adf11e18d6507779bf95fad">mlir::AsmParser::parseType()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00602">print()</a>, <a class="el" href="OpImplementation_8h_source.html#l00358">mlir::OpAsmPrinter::printOperands()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#a681280bde1406e824e1d4626fe257e1b">mlir::OpAsmPrinter::printOptionalAttrDict()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00451">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">mlir::OpAsmParser::resolveOperand()</a>, <a class="el" href="OpImplementation_8h_source.html#l01388">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">mlir::AsmParser::Square</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="Verifier_8cpp_source.html#l00372">mlir::verify()</a>.</p>

</div>
</div>
<a id="a265e2c0706658d6b14273bba2445f3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265e2c0706658d6b14273bba2445f3dc">&#9670;&nbsp;</a></span>printGlobalMemrefOpTypeAndInitialValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> printGlobalMemrefOpTypeAndInitialValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeAttr&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>initialValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l01428">1428</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02484">mlir::AsmPrinter::printAttributeWithoutType()</a>.</p>

</div>
</div>
<a id="a9d9684bbc8a0bb512dfa8dcd662c86a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9684bbc8a0bb512dfa8dcd662c86a5">&#9670;&nbsp;</a></span>produceSubViewErrorMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> produceSubViewErrorMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75">SliceVerificationResult</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>expectedType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02593">2593</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00279">mlir::Type::cast()</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a6341e1bfc09d56fa49bb1b9400459d8e">mlir::ElemTypeMismatch</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00327">mlir::emitError()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00061">mlir::extractFromI64ArrayAttr()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00173">mlir::getMixedSizes()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02567">isRankReducedMemRefType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l01009">mlir::isStrided()</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36297823a9892f9936fba1805a1c52ca">mlir::LayoutMismatch</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a36a2220daadd84aaba239b031cf4cd23">mlir::MemSpaceMismatch</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a780dd32ee9af184442cea3f2a2a75271">mlir::RankTooLarge</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a87c69361ccd090c9c844e19d08432a26">mlir::SizeMismatch</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">mlir::Success</a>, and <a class="el" href="Verifier_8cpp_source.html#l00372">mlir::verify()</a>.</p>

</div>
</div>
<a id="a4c8ebb88a6b0251c5ae942554571d621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8ebb88a6b0251c5ae942554571d621">&#9670;&nbsp;</a></span>replaceConstantUsesOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool replaceConstantUsesOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>maybeConstants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(int64_t)&gt;&#160;</td>
          <td class="paramname"><em>isDynamic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to perform the replacement of all constant uses of <code>values</code> by a materialized constant extracted from <code>maybeConstants</code>. </p>
<p><code>values</code> and <code>maybeConstants</code> are expected to have the same size. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l01294">1294</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00418">mlir::OpBuilder::create()</a>.</p>

</div>
</div>
<a id="afcb10f259303d819184a4c81b159372a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb10f259303d819184a4c81b159372a">&#9670;&nbsp;</a></span>verifyAllocLikeOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocLikeOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> verifyAllocLikeOp </td>
          <td>(</td>
          <td class="paramtype">AllocLikeOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00127">127</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01407">mlir::RewritePatternSet::add()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00203">mlir::OperationState::addRegion()</a>, <a class="el" href="OperationSupport_8h_source.html#l00634">mlir::OperationState::attributes</a>, <a class="el" href="Builders_8cpp_source.html#l00418">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00327">mlir::emitError()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00259">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="OperationSupport_8h_source.html#l00629">mlir::OperationState::location</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00022">mlir::matchConstantIndex()</a>, <a class="el" href="Matchers_8h_source.html#l00329">mlir::matchPattern()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ac8dd551c69e3209e1d5ca180c4778362">mlir::AsmParser::parseOptionalArrowTypeList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf4b8149e630797ac1ac90d8e118c4b">mlir::AsmParser::parseOptionalAttrDict()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a1aa6346885471aae41b7f63c33894af5">mlir::OpAsmParser::parseRegion()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00602">print()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#a681280bde1406e824e1d4626fe257e1b">mlir::OpAsmPrinter::printOptionalAttrDict()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#aca2979fa160a91a41e9aae802edcb7d1">mlir::OpAsmPrinter::printRegion()</a>, <a class="el" href="OperationSupport_8h_source.html#l00638">mlir::OperationState::regions</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00176">mlir::MemRefType::Builder::setShape()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="OperationSupport_8h_source.html#l00633">mlir::OperationState::types</a>, <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>, and <a class="el" href="Verifier_8cpp_source.html#l00372">mlir::verify()</a>.</p>

</div>
</div>
<a id="a3211f00d69d9462b4103bba629b75337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3211f00d69d9462b4103bba629b75337">&#9670;&nbsp;</a></span>verifyCollapsedShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> verifyCollapsedShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>collapsedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>expandedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ab973fb931221b9539fe0ffd408e261ff">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowMultipleDynamicDimsPerGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for verifying the shape of ExpandShapeOp and ResultShapeOp result and operand. </p>
<p>Layout maps are verified separately.</p>
<p>If <code>allowMultipleDynamicDimsPerGroup</code>, multiple dynamic dimensions are allowed in a reassocation group. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l01863">1863</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00132">mlir::convertReassociationIndicesToExprs()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00512">mlir::Operation::emitOpError()</a>, <a class="el" href="Matchers_8h_source.html#l00230">mlir::detail::enumerate()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00183">mlir::getSymbolLessAffineMaps()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l02068">computeCollapsedLayoutMap()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l01956">computeExpandedLayoutMap()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Nov 4 2022 16:35:30 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
