<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::sparse_tensor::SparseTensorStorage&lt; P, I, V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">16.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1sparse__tensor.html">sparse_tensor</a></li><li class="navelem"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">SparseTensorStorage</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::sparse_tensor::SparseTensorStorage&lt; P, I, V &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A memory-resident sparse tensor using a storage scheme based on per-dimension sparse/dense annotations.  
 <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Storage_8h_source.html">mlir/ExecutionEngine/SparseTensor/Storage.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::sparse_tensor::SparseTensorStorage&lt; P, I, V &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classmlir_1_1sparse__tensor_1_1SparseTensorStorage__inherit__graph.png" border="0" usemap="#mlir_1_1sparse__tensor_1_1SparseTensorStorage_3_01P_00_01I_00_01V_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1sparse__tensor_1_1SparseTensorStorage_3_01P_00_01I_00_01V_01_4_inherit__map" id="mlir_1_1sparse__tensor_1_1SparseTensorStorage_3_01P_00_01I_00_01V_01_4_inherit__map">
<area shape="rect" id="node2" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html" title="Abstract base class for SparseTensorStorage&lt;P,I,V&gt;. " alt="" coords="5,5,204,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for mlir::sparse_tensor::SparseTensorStorage&lt; P, I, V &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classmlir_1_1sparse__tensor_1_1SparseTensorStorage__coll__graph.png" border="0" usemap="#mlir_1_1sparse__tensor_1_1SparseTensorStorage_3_01P_00_01I_00_01V_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1sparse__tensor_1_1SparseTensorStorage_3_01P_00_01I_00_01V_01_4_coll__map" id="mlir_1_1sparse__tensor_1_1SparseTensorStorage_3_01P_00_01I_00_01V_01_4_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html" title="Abstract base class for SparseTensorStorage&lt;P,I,V&gt;. " alt="" coords="5,5,204,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6386d96bccf08604187705b11385933b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#a6386d96bccf08604187705b11385933b">SparseTensorStorage</a> (const std::vector&lt; uint64_t &gt; &amp;dimSizes, const uint64_t *perm, const <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> *sparsity, <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorCOO.html">SparseTensorCOO</a>&lt; V &gt; *coo)</td></tr>
<tr class="memdesc:a6386d96bccf08604187705b11385933b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sparse tensor storage scheme with the given dimensions, permutation, and per-dimension dense/sparse annotations, using the coordinate scheme tensor for the initial contents if provided.  <a href="#a6386d96bccf08604187705b11385933b">More...</a><br /></td></tr>
<tr class="separator:a6386d96bccf08604187705b11385933b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b0cc5a8f589bd390bafc749ddd88ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#a14b0cc5a8f589bd390bafc749ddd88ed">SparseTensorStorage</a> (const std::vector&lt; uint64_t &gt; &amp;dimSizes, const uint64_t *perm, const <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> *sparsity, const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> &amp;tensor)</td></tr>
<tr class="memdesc:a14b0cc5a8f589bd390bafc749ddd88ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sparse tensor storage scheme with the given dimensions, permutation, and per-dimension dense/sparse annotations, using the given sparse tensor for the initial contents.  <a href="#a14b0cc5a8f589bd390bafc749ddd88ed">More...</a><br /></td></tr>
<tr class="separator:a14b0cc5a8f589bd390bafc749ddd88ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcd0d90ebd412dbeee81d6085676c31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#addcd0d90ebd412dbeee81d6085676c31">~SparseTensorStorage</a> () final=default</td></tr>
<tr class="separator:addcd0d90ebd412dbeee81d6085676c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e4c222ec7bc045648983db6da4517b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#a97e4c222ec7bc045648983db6da4517b">getPointers</a> (std::vector&lt; P &gt; **out, uint64_t d) final</td></tr>
<tr class="memdesc:a97e4c222ec7bc045648983db6da4517b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially specialize these getter methods based on template types.  <a href="#a97e4c222ec7bc045648983db6da4517b">More...</a><br /></td></tr>
<tr class="separator:a97e4c222ec7bc045648983db6da4517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d94784a43cbd5537055a8e8b1fa439d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#a1d94784a43cbd5537055a8e8b1fa439d">getIndices</a> (std::vector&lt; I &gt; **out, uint64_t d) final</td></tr>
<tr class="separator:a1d94784a43cbd5537055a8e8b1fa439d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad0a87fd98cb345960426459e9c0705"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#a0ad0a87fd98cb345960426459e9c0705">getValues</a> (std::vector&lt; V &gt; **out) final</td></tr>
<tr class="separator:a0ad0a87fd98cb345960426459e9c0705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d114d5d7d1a8265353b7782e6fa7dc0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#a0d114d5d7d1a8265353b7782e6fa7dc0">getIndex</a> (uint64_t d, uint64_t pos) const final</td></tr>
<tr class="separator:a0d114d5d7d1a8265353b7782e6fa7dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad116f385fadb4f4072701f74cbcf8545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#ad116f385fadb4f4072701f74cbcf8545">lexInsert</a> (const uint64_t *cursor, V val) final</td></tr>
<tr class="memdesc:ad116f385fadb4f4072701f74cbcf8545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially specialize lexicographical insertions based on template types.  <a href="#ad116f385fadb4f4072701f74cbcf8545">More...</a><br /></td></tr>
<tr class="separator:ad116f385fadb4f4072701f74cbcf8545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfab41017d2cc07ef03e1e75af273b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#acfab41017d2cc07ef03e1e75af273b34">expInsert</a> (uint64_t *cursor, V *values, bool *filled, uint64_t *added, uint64_t count) final</td></tr>
<tr class="memdesc:acfab41017d2cc07ef03e1e75af273b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially specialize expanded insertions based on template types.  <a href="#acfab41017d2cc07ef03e1e75af273b34">More...</a><br /></td></tr>
<tr class="separator:acfab41017d2cc07ef03e1e75af273b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeea32068f6a9a9c9fa5f2cc10d7e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#aadeea32068f6a9a9c9fa5f2cc10d7e66">endInsert</a> () final</td></tr>
<tr class="memdesc:aadeea32068f6a9a9c9fa5f2cc10d7e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes lexicographic insertions.  <a href="#aadeea32068f6a9a9c9fa5f2cc10d7e66">More...</a><br /></td></tr>
<tr class="separator:aadeea32068f6a9a9c9fa5f2cc10d7e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2031fc282b1c8466b7b9c30f1d422c36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#a2031fc282b1c8466b7b9c30f1d422c36">newEnumerator</a> (<a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorEnumeratorBase.html">SparseTensorEnumeratorBase</a>&lt; V &gt; **out, uint64_t rank, const uint64_t *perm) const final</td></tr>
<tr class="memdesc:a2031fc282b1c8466b7b9c30f1d422c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new enumerator for this classes <code>&lt;P,I,V&gt;</code> types and erase the <code>&lt;P,I&gt;</code> parts from the type.  <a href="#a2031fc282b1c8466b7b9c30f1d422c36">More...</a><br /></td></tr>
<tr class="separator:a2031fc282b1c8466b7b9c30f1d422c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7970a50da9b6965cc123e5b5c5eb80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorCOO.html">SparseTensorCOO</a>&lt; V &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#adb7970a50da9b6965cc123e5b5c5eb80">toCOO</a> (const uint64_t *perm) const</td></tr>
<tr class="memdesc:adb7970a50da9b6965cc123e5b5c5eb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this sparse tensor storage scheme as a new memory-resident sparse tensor in coordinate scheme with the given dimension order.  <a href="#adb7970a50da9b6965cc123e5b5c5eb80">More...</a><br /></td></tr>
<tr class="separator:adb7970a50da9b6965cc123e5b5c5eb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">mlir::sparse_tensor::SparseTensorStorageBase</a></td></tr>
<tr class="memitem:ae2ea06a1b9013d93bb603d85c9673174 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ae2ea06a1b9013d93bb603d85c9673174">SparseTensorStorageBase</a> (const std::vector&lt; uint64_t &gt; &amp;dimSizes, const uint64_t *perm, const <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> *sparsity)</td></tr>
<tr class="memdesc:ae2ea06a1b9013d93bb603d85c9673174 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new storage object.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ae2ea06a1b9013d93bb603d85c9673174">More...</a><br /></td></tr>
<tr class="separator:ae2ea06a1b9013d93bb603d85c9673174 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6473d9303808ece08e5dfc2f7fbab2 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#abb6473d9303808ece08e5dfc2f7fbab2">~SparseTensorStorageBase</a> ()=default</td></tr>
<tr class="separator:abb6473d9303808ece08e5dfc2f7fbab2 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb1a16b341bd13f0139ae9d6f2879be inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#abcb1a16b341bd13f0139ae9d6f2879be">getRank</a> () const</td></tr>
<tr class="memdesc:abcb1a16b341bd13f0139ae9d6f2879be inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the rank of the tensor.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#abcb1a16b341bd13f0139ae9d6f2879be">More...</a><br /></td></tr>
<tr class="separator:abcb1a16b341bd13f0139ae9d6f2879be inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f47a827baeaf94643e87241063a296 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; uint64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a97f47a827baeaf94643e87241063a296">getDimSizes</a> () const</td></tr>
<tr class="memdesc:a97f47a827baeaf94643e87241063a296 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dimension-sizes array, in storage-order.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a97f47a827baeaf94643e87241063a296">More...</a><br /></td></tr>
<tr class="separator:a97f47a827baeaf94643e87241063a296 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad710f72a2198d3e4633586d4453cedb7 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ad710f72a2198d3e4633586d4453cedb7">getDimSize</a> (uint64_t d) const</td></tr>
<tr class="memdesc:ad710f72a2198d3e4633586d4453cedb7 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely looks up the size of the given (storage-order) dimension.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ad710f72a2198d3e4633586d4453cedb7">More...</a><br /></td></tr>
<tr class="separator:ad710f72a2198d3e4633586d4453cedb7 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aae613dabaf572ec6cf1845a408f277 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; uint64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a3aae613dabaf572ec6cf1845a408f277">getRev</a> () const</td></tr>
<tr class="memdesc:a3aae613dabaf572ec6cf1845a408f277 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "reverse" permutation, which maps this object's storage-order to the tensor's semantic-order.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a3aae613dabaf572ec6cf1845a408f277">More...</a><br /></td></tr>
<tr class="separator:a3aae613dabaf572ec6cf1845a408f277 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401e3ffd061b0c72590e597a4760b5a5 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a401e3ffd061b0c72590e597a4760b5a5">getDimTypes</a> () const</td></tr>
<tr class="memdesc:a401e3ffd061b0c72590e597a4760b5a5 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dimension-types array, in storage-order.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a401e3ffd061b0c72590e597a4760b5a5">More...</a><br /></td></tr>
<tr class="separator:a401e3ffd061b0c72590e597a4760b5a5 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847fc7f833ac37362ffc969e6172f87a inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a847fc7f833ac37362ffc969e6172f87a">getDimType</a> (uint64_t d) const</td></tr>
<tr class="memdesc:a847fc7f833ac37362ffc969e6172f87a inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely looks up the level-type of the given (storage-order) dimension.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a847fc7f833ac37362ffc969e6172f87a">More...</a><br /></td></tr>
<tr class="separator:a847fc7f833ac37362ffc969e6172f87a inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5521dad4ae35151316770c471d89582b inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a5521dad4ae35151316770c471d89582b">isDenseDim</a> (uint64_t d) const</td></tr>
<tr class="memdesc:a5521dad4ae35151316770c471d89582b inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the (storage-order) dimension uses dense storage.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a5521dad4ae35151316770c471d89582b">More...</a><br /></td></tr>
<tr class="separator:a5521dad4ae35151316770c471d89582b inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ff10dcd82c966d68bd9695aae231f2 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a96ff10dcd82c966d68bd9695aae231f2">isCompressedDim</a> (uint64_t d) const</td></tr>
<tr class="memdesc:a96ff10dcd82c966d68bd9695aae231f2 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the (storage-order) dimension uses compressed storage.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a96ff10dcd82c966d68bd9695aae231f2">More...</a><br /></td></tr>
<tr class="separator:a96ff10dcd82c966d68bd9695aae231f2 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c41196af20cc645914c9a89ef567309 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a1c41196af20cc645914c9a89ef567309">isSingletonDim</a> (uint64_t d) const</td></tr>
<tr class="memdesc:a1c41196af20cc645914c9a89ef567309 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the (storage-order) dimension uses singleton storage.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a1c41196af20cc645914c9a89ef567309">More...</a><br /></td></tr>
<tr class="separator:a1c41196af20cc645914c9a89ef567309 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e8bda389976bdd0e42a96786a8f7a1 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a50e8bda389976bdd0e42a96786a8f7a1">isOrderedDim</a> (uint64_t d) const</td></tr>
<tr class="memdesc:a50e8bda389976bdd0e42a96786a8f7a1 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the (storage-order) dimension is ordered.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a50e8bda389976bdd0e42a96786a8f7a1">More...</a><br /></td></tr>
<tr class="separator:a50e8bda389976bdd0e42a96786a8f7a1 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58d42b855b27d8a7ab63e435cffeb33 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#aa58d42b855b27d8a7ab63e435cffeb33">isUniqueDim</a> (uint64_t d) const</td></tr>
<tr class="memdesc:aa58d42b855b27d8a7ab63e435cffeb33 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the (storage-order) dimension is unique.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#aa58d42b855b27d8a7ab63e435cffeb33">More...</a><br /></td></tr>
<tr class="separator:aa58d42b855b27d8a7ab63e435cffeb33 inherit pub_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a286ef9f3cf129a5de0651b3462787f10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">SparseTensorStorage</a>&lt; P, I, V &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#a286ef9f3cf129a5de0651b3462787f10">newSparseTensor</a> (uint64_t rank, const uint64_t *shape, const uint64_t *perm, const <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> *sparsity, <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorCOO.html">SparseTensorCOO</a>&lt; V &gt; *coo)</td></tr>
<tr class="memdesc:a286ef9f3cf129a5de0651b3462787f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method.  <a href="#a286ef9f3cf129a5de0651b3462787f10">More...</a><br /></td></tr>
<tr class="separator:a286ef9f3cf129a5de0651b3462787f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad2c6e2fee455f71a5b557b0e6f8b7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">SparseTensorStorage</a>&lt; P, I, V &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#acad2c6e2fee455f71a5b557b0e6f8b7a">newSparseTensor</a> (uint64_t rank, const uint64_t *shape, const uint64_t *perm, const <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> *sparsity, const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> *source)</td></tr>
<tr class="memdesc:acad2c6e2fee455f71a5b557b0e6f8b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method.  <a href="#acad2c6e2fee455f71a5b557b0e6f8b7a">More...</a><br /></td></tr>
<tr class="separator:acad2c6e2fee455f71a5b557b0e6f8b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab7bfa9a0a73e72bbfebd49436905903a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#ab7bfa9a0a73e72bbfebd49436905903a">SparseTensorEnumerator&lt; P, I, V &gt;</a></td></tr>
<tr class="separator:ab7bfa9a0a73e72bbfebd49436905903a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">mlir::sparse_tensor::SparseTensorStorageBase</a></td></tr>
<tr class="memitem:a4b67a9f19f16f2eb12b14158492032a1 inherit pro_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a4b67a9f19f16f2eb12b14158492032a1">SparseTensorStorageBase</a> (const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> &amp;)=default</td></tr>
<tr class="separator:a4b67a9f19f16f2eb12b14158492032a1 inherit pro_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ddf953946e62decb2b7716c8969ac2 inherit pro_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a44ddf953946e62decb2b7716c8969ac2">operator=</a> (const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> &amp;)=delete</td></tr>
<tr class="separator:a44ddf953946e62decb2b7716c8969ac2 inherit pro_methods_classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename P, typename I, typename V&gt;<br />
class mlir::sparse_tensor::SparseTensorStorage&lt; P, I, V &gt;</h3>

<p>A memory-resident sparse tensor using a storage scheme based on per-dimension sparse/dense annotations. </p>
<p>This data structure provides a bufferized form of a sparse tensor type. In contrast to generating setup methods for each differently annotated sparse tensor, this method provides a convenient "one-size-fits-all" solution that simply takes an input tensor and annotations to implement all required setup in a general manner. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00193">193</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6386d96bccf08604187705b11385933b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6386d96bccf08604187705b11385933b">&#9670;&nbsp;</a></span>SparseTensorStorage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename I , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::<a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">SparseTensorStorage</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> *&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorCOO.html">SparseTensorCOO</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>coo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a sparse tensor storage scheme with the given dimensions, permutation, and per-dimension dense/sparse annotations, using the coordinate scheme tensor for the initial contents if provided. </p>
<p>Precondition: <code>perm</code> and <code>sparsity</code> must be valid for <code>dimSizes.size()</code>. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00789">789</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00060">ASSERT_DENSE_DIM</a>, <a class="el" href="CheckedMul_8h_source.html#l00038">mlir::sparse_tensor::detail::checkedMul()</a>, <a class="el" href="Storage_8h_source.html#l00094">mlir::sparse_tensor::SparseTensorStorageBase::getDimSizes()</a>, <a class="el" href="COO_8h_source.html#l00137">mlir::sparse_tensor::SparseTensorCOO&lt; V &gt;::getDimSizes()</a>, <a class="el" href="COO_8h_source.html#l00140">mlir::sparse_tensor::SparseTensorCOO&lt; V &gt;::getElements()</a>, <a class="el" href="Storage_8h_source.html#l00091">mlir::sparse_tensor::SparseTensorStorageBase::getRank()</a>, <a class="el" href="Storage_8h_source.html#l00119">mlir::sparse_tensor::SparseTensorStorageBase::isCompressedDim()</a>, <a class="el" href="Storage_8h_source.html#l00124">mlir::sparse_tensor::SparseTensorStorageBase::isSingletonDim()</a>, and <a class="el" href="COO_8h_source.html#l00189">mlir::sparse_tensor::SparseTensorCOO&lt; V &gt;::sort()</a>.</p>

</div>
</div>
<a id="a14b0cc5a8f589bd390bafc749ddd88ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b0cc5a8f589bd390bafc749ddd88ed">&#9670;&nbsp;</a></span>SparseTensorStorage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename I , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::<a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">SparseTensorStorage</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> *&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a sparse tensor storage scheme with the given dimensions, permutation, and per-dimension dense/sparse annotations, using the given sparse tensor for the initial contents. </p>
<p>Preconditions:</p><ul>
<li><code>perm</code> and <code>sparsity</code> must be valid for <code>dimSizes.size()</code>.</li>
<li>The <code>tensor</code> must have the same value type <code>V</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00834">834</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00060">ASSERT_DENSE_DIM</a>, <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorEnumeratorBase.html#a4456cfc57021e301017ae99912b0c4cd">mlir::sparse_tensor::SparseTensorEnumeratorBase&lt; V &gt;::forallElements()</a>, <a class="el" href="NNZ_8cpp_source.html#l00066">mlir::sparse_tensor::SparseTensorNNZ::forallIndices()</a>, <a class="el" href="Storage_8h_source.html#l00094">mlir::sparse_tensor::SparseTensorStorageBase::getDimSizes()</a>, <a class="el" href="Storage_8h_source.html#l00107">mlir::sparse_tensor::SparseTensorStorageBase::getDimTypes()</a>, <a class="el" href="Storage_8h_source.html#l00091">mlir::sparse_tensor::SparseTensorStorageBase::getRank()</a>, <a class="el" href="Storage_8h_source.html#l00703">mlir::sparse_tensor::SparseTensorNNZ::initialize()</a>, <a class="el" href="Storage_8h_source.html#l00119">mlir::sparse_tensor::SparseTensorStorageBase::isCompressedDim()</a>, <a class="el" href="Storage_8h_source.html#l00116">mlir::sparse_tensor::SparseTensorStorageBase::isDenseDim()</a>, and <a class="el" href="Storage_8h_source.html#l00124">mlir::sparse_tensor::SparseTensorStorageBase::isSingletonDim()</a>.</p>

</div>
</div>
<a id="addcd0d90ebd412dbeee81d6085676c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addcd0d90ebd412dbeee81d6085676c31">&#9670;&nbsp;</a></span>~SparseTensorStorage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P, typename I, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::~<a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">SparseTensorStorage</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aadeea32068f6a9a9c9fa5f2cc10d7e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadeea32068f6a9a9c9fa5f2cc10d7e66">&#9670;&nbsp;</a></span>endInsert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P, typename I, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::endInsert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalizes lexicographic insertions. </p>

<p>Implements <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ab0f190362d8c051075064b6cd2d64c2e">mlir::sparse_tensor::SparseTensorStorageBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00312">312</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

</div>
</div>
<a id="acfab41017d2cc07ef03e1e75af273b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfab41017d2cc07ef03e1e75af273b34">&#9670;&nbsp;</a></span>expInsert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P, typename I, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::expInsert </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>filled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partially specialize expanded insertions based on template types. </p>
<p>Note that this method resets the values/filled-switch array back to all-zero/false while only iterating over the nonzero elements. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00285">285</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00091">mlir::sparse_tensor::SparseTensorStorageBase::getRank()</a>.</p>

</div>
</div>
<a id="a0d114d5d7d1a8265353b7782e6fa7dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d114d5d7d1a8265353b7782e6fa7dc0">&#9670;&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P, typename I, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::getIndex </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a0c3bfd679e37fad5db8e218e3368dc68">mlir::sparse_tensor::SparseTensorStorageBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00262">262</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00057">ASSERT_COMPRESSED_OR_SINGLETON_DIM</a>.</p>

</div>
</div>
<a id="a1d94784a43cbd5537055a8e8b1fa439d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d94784a43cbd5537055a8e8b1fa439d">&#9670;&nbsp;</a></span>getIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P, typename I, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::getIndices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; I &gt; **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00256">256</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00053">ASSERT_VALID_DIM</a>.</p>

</div>
</div>
<a id="a97e4c222ec7bc045648983db6da4517b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e4c222ec7bc045648983db6da4517b">&#9670;&nbsp;</a></span>getPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P, typename I, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::getPointers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; P &gt; **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partially specialize these getter methods based on template types. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00252">252</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00053">ASSERT_VALID_DIM</a>.</p>

</div>
</div>
<a id="a0ad0a87fd98cb345960426459e9c0705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad0a87fd98cb345960426459e9c0705">&#9670;&nbsp;</a></span>getValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P, typename I, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::getValues </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; V &gt; **&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00260">260</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

</div>
</div>
<a id="ad116f385fadb4f4072701f74cbcf8545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad116f385fadb4f4072701f74cbcf8545">&#9670;&nbsp;</a></span>lexInsert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P, typename I, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::lexInsert </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partially specialize lexicographical insertions based on template types. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00269">269</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

</div>
</div>
<a id="a2031fc282b1c8466b7b9c30f1d422c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2031fc282b1c8466b7b9c30f1d422c36">&#9670;&nbsp;</a></span>newEnumerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P, typename I, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::newEnumerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorEnumeratorBase.html">SparseTensorEnumeratorBase</a>&lt; V &gt; **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new enumerator for this classes <code>&lt;P,I,V&gt;</code> types and erase the <code>&lt;P,I&gt;</code> parts from the type. </p>
<p>Callers must make sure to delete the enumerator when they're done with it. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00322">322</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

</div>
</div>
<a id="a286ef9f3cf129a5de0651b3462787f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286ef9f3cf129a5de0651b3462787f10">&#9670;&nbsp;</a></span>newSparseTensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename I , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">SparseTensorStorage</a>&lt; P, I, V &gt; * <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::newSparseTensor </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> *&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorCOO.html">SparseTensorCOO</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>coo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method. </p>
<p>Constructs a sparse tensor storage scheme with the given dimensions, permutation, and per-dimension dense/sparse annotations, using the coordinate scheme tensor for the initial contents if provided. In the latter case, the coordinate scheme must respect the same permutation as is desired for the new sparse tensor storage.</p>
<p>Precondition: <code>shape</code>, <code>perm</code>, and <code>sparsity</code> must be valid for <code>rank</code>. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00752">752</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8cpp_source.html#l00108">mlir::sparse_tensor::detail::assertPermutedSizesMatchShape()</a>, and <a class="el" href="COO_8h_source.html#l00137">mlir::sparse_tensor::SparseTensorCOO&lt; V &gt;::getDimSizes()</a>.</p>

</div>
</div>
<a id="acad2c6e2fee455f71a5b557b0e6f8b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad2c6e2fee455f71a5b557b0e6f8b7a">&#9670;&nbsp;</a></span>newSparseTensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename I , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">SparseTensorStorage</a>&lt; P, I, V &gt; * <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::newSparseTensor </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1sparse__tensor.html#aa09f02b16598f192895bfa41d8032a95">DimLevelType</a> *&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method. </p>
<p>Constructs a sparse tensor storage scheme with the given dimensions, permutation, and per-dimension dense/sparse annotations, using the sparse tensor for the initial contents.</p>
<p>Preconditions:</p><ul>
<li><code>shape</code>, <code>perm</code>, and <code>sparsity</code> must be valid for <code>rank</code>.</li>
<li>The <code>tensor</code> must have the same value type <code>V</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00772">772</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8cpp_source.html#l00108">mlir::sparse_tensor::detail::assertPermutedSizesMatchShape()</a>, and <a class="el" href="Storage_8h_source.html#l00590">mlir::sparse_tensor::SparseTensorEnumeratorBase&lt; V &gt;::permutedSizes()</a>.</p>

</div>
</div>
<a id="adb7970a50da9b6965cc123e5b5c5eb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7970a50da9b6965cc123e5b5c5eb80">&#9670;&nbsp;</a></span>toCOO()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P, typename I, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorCOO.html">SparseTensorCOO</a>&lt;V&gt;* <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html">mlir::sparse_tensor::SparseTensorStorage</a>&lt; P, I, V &gt;::toCOO </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this sparse tensor storage scheme as a new memory-resident sparse tensor in coordinate scheme with the given dimension order. </p>
<p>Precondition: <code>perm</code> must be valid for <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#abcb1a16b341bd13f0139ae9d6f2879be" title="Gets the rank of the tensor. ">getRank()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00331">331</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="COO_8h_source.html#l00155">mlir::sparse_tensor::SparseTensorCOO&lt; V &gt;::add()</a>, <a class="el" href="Storage_8h_source.html#l00055">ASSERT_COMPRESSED_DIM</a>, <a class="el" href="Storage_8h_source.html#l00057">ASSERT_COMPRESSED_OR_SINGLETON_DIM</a>, <a class="el" href="Storage_8h_source.html#l00060">ASSERT_DENSE_DIM</a>, <a class="el" href="CheckedMul_8h_source.html#l00038">mlir::sparse_tensor::detail::checkedMul()</a>, <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorEnumeratorBase.html#a4456cfc57021e301017ae99912b0c4cd">mlir::sparse_tensor::SparseTensorEnumeratorBase&lt; V &gt;::forallElements()</a>, <a class="el" href="Storage_8h_source.html#l00094">mlir::sparse_tensor::SparseTensorStorageBase::getDimSizes()</a>, <a class="el" href="COO_8h_source.html#l00140">mlir::sparse_tensor::SparseTensorCOO&lt; V &gt;::getElements()</a>, <a class="el" href="Storage_8h_source.html#l00091">mlir::sparse_tensor::SparseTensorStorageBase::getRank()</a>, <a class="el" href="Storage_8h_source.html#l00119">mlir::sparse_tensor::SparseTensorStorageBase::isCompressedDim()</a>, <a class="el" href="Storage_8h_source.html#l00116">mlir::sparse_tensor::SparseTensorStorageBase::isDenseDim()</a>, <a class="el" href="Storage_8h_source.html#l00124">mlir::sparse_tensor::SparseTensorStorageBase::isSingletonDim()</a>, <a class="el" href="Storage_8h_source.html#l00132">mlir::sparse_tensor::SparseTensorStorageBase::isUniqueDim()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00201">max()</a>, <a class="el" href="ErrorHandling_8h_source.html#l00037">MLIR_SPARSETENSOR_FATAL</a>, <a class="el" href="Storage_8h_source.html#l00590">mlir::sparse_tensor::SparseTensorEnumeratorBase&lt; V &gt;::permutedSizes()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00160">value</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab7bfa9a0a73e72bbfebd49436905903a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bfa9a0a73e72bbfebd49436905903a">&#9670;&nbsp;</a></span>SparseTensorEnumerator< P, I, V ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P, typename I, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfriend.html">friend</a> class <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorEnumerator.html">SparseTensorEnumerator</a>&lt; P, I, V &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00518">518</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/mlir/ExecutionEngine/SparseTensor/<a class="el" href="Storage_8h_source.html">Storage.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Nov 4 2022 16:35:35 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
